<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Code-Only Agent ‚Ä¢ Rijnard van Tonder</title>
    <meta
      name="description"
      content="When code execution is all you need. Exploring what happens when an AI agent can only write and run code."
    />

    <link rel="stylesheet" href="../assets/normalize.css" />
    <link rel="stylesheet" href="../assets/main.css" />
    <link
      href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Vollkorn"
      rel="stylesheet"
      type="text/css"
    />
    <link
      rel="canonical"
      href="https://rijnard.com/blog/the-code-only-agent.html"
    />

    <style>
      /* Override default center alignment for author name - make it right aligned on all screen sizes */
      .author-container h1,
      .author-container p {
        text-align: right;
      }

      /* Make blog nav left aligned on mobile, centered above hr */
      @media (max-width: 767px) {
        .blog-nav {
          text-align: left;
        }
      }

      /* Remove bullet indentation in article */
      .content ul {
        padding: 0 !important;
        margin: 10px !important;
        list-style-position: inside;
      }

      .content ul li {
        margin-bottom: 1em;
        text-align: justify;
      }
    </style>

    <meta name="author" content="Rijnard van Tonder" />
    <meta property="og:title" content="The Code-Only Agent" />
    <meta
      property="og:description"
      content="When code execution is all you need. Exploring what happens when an AI agent can only write and run code."
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://rijnard.com/blog/the-code-only-agent.html"
    />
    <meta
      property="og:image"
      content="https://rijnard.com/assets/og-code-only.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@rvtond" />
    <meta
      name="twitter:image"
      content="https://rijnard.com/assets/og-code-only.png"
    />
    <script
      async
      defer
      data-domain="rijnard.com"
      src="https://plausible.io/js/plausible.js"
    ></script>
  </head>

  <body>
    <div id="base" class="wrapper">
      <header>
        <div class="author-container">
          <p style="font-size: 1.5rem; margin: 0">
            <a href="../index.html">Rijnard<br />van Tonder</a>
          </p>
          <p style="font-size: 0.9rem; margin: 0; padding: 0;">
            <a href="https://x.com/rvtond" style="text-decoration: underline;">ùïè @rvtond</a>
          </p>
        </div>
        <hr />
        <nav class="blog-nav">
          <a style="text-decoration: underline" href="../index.html">Home</a>
          <br />
          <a style="text-decoration: underline" href="index.html"
            >‚Üê Back to all posts</a
          >
        </nav>
      </header>

      <main>
        <article class="content">
          <h1 style="color: #990033">The Code-Only Agent</h1>
          <p style="font-size: 1.2em; font-style: italic; margin: 0;">
            When Code Execution is All You Need
          </p>
          <p style="text-align: center; margin: 0; padding-top: 1.2em; padding-bottom: 0.8em;">
            <img src="../assets/code-only.svg" alt="Code-Only Agent" style="max-width: 100%; height: auto; margin: 0;" />
          </p>

          <p style="margin-top: 0em;">
            If you're building an agent, you're probably overwhelmed. Tools.
            MCP. Subagents. Skills. The ecosystem pushes you toward complexity,
            toward "the right way" to do things. You should know: Concepts like
            "Skills" and "MCP" are actually outcomes of an
            <i>ongoing learning process</i> of humans figuring stuff out. The
            space is <i>wide open</i> for exploration. With this mindset I
            wanted to try something different. Simplify the assumptions.
          </p>

          <p>
            What if the agent only had
            <b
              ><i><code>one tool</code></i></b
            >? Not just any tool, but the most powerful one. The
            <b><code>Turing-complete</code></b> one: <b><i>execute code</i></b
            >.
          </p>

          <p>
            Truly one tool means: no `bash`, no `ls`, no `grep`. Only
            <b><code>execute_code</code></b
            >. And you <i>enforce</i> it.
          </p>

          <p>
            When you watch an agent run, you might think: "I wonder what tools
            it'll use to figure this out. Oh look, it ran `ls`. That makes
            sense. Next, `grep`. Cool."
          </p>
          <p>
            The simpler Code-Only paradigm makes that question irrelevant. The
            question shifts from "what tools?" to "what code will it produce?"
            And that's when things get interesting.
          </p>

					<h2><span style="font-size: 1.2rem"><code>execute_code</code></span>: One Tool to Rule Them All</h2>

          <p>Traditional prompting works like this:</p>

          <p>
            &gt; Agent, do <b><i>thing</i></b>
            <br />
            &gt; Agent
            <span
              style="border: 1px solid; padding-left: 2px; padding-right: 4px"
              ><b><i>responds</i></b></span
            >
            with <b><i>thing</i></b>
          </p>

          <p>Contrast with:</p>

          <p>
            &gt; Agent, do <b><i>thing</i></b>
            <br />
            &gt; Agent
            <span
              style="border: 1px solid; padding-left: 2px; padding-right: 4px"
              ><b><i>creates and runs code</i></b></span
            >
            to do <b><i>thing</i></b>
          </p>

          <p>
            It does this every time. No, really,
            <b
              ><i><code>every</code></i></b
            >
            time. Pick a runtime for our Code-Only agent, say Python. It needs
            to find a file? It writes Python code to find the file and executes
            the code. Maybe it runs <b><i>rglob</i></b
            >. Maybe it does <b><i>os.walk</i></b
            >.
          </p>

          <p>
            It needs to create a script that crawls a website? It doesn't write
            the script to your filesystem (reminder: there's no
            <b><i>create_file</i></b> tool to do that!). It
            <b><i>writes code to output a script that crawls a website</i></b
            >.<sup><a href="#fn1" style="text-decoration: none;">1</a></sup>
          </p>

          <p>
            We make it so that there is literally no way for the agent to
            <i><b>do</b></i> anything productive without
            <b><i>writing code</i></b
            >.
          </p>

          <p>
            So what? Why do this? You're probably thinking, how is this useful?
            Just give it `bash` tool already man.
          </p>

          <p>
            Let's think a bit more deeply what's happening. Traditional agents
            respond with something. Tell it to find some DNA pattern across 100
            files. It might `ls` and `grep`, it might do that in some
            nondeterministic order, it'll figure out <i><b>an answer</b></i> and
            maybe you continue interacting because it missed a directory or you
            added more files. After some time, you end up with a conversation of
            tool calls, responses, and an answer.
          </p>

          <p>
            At some point the agent might even write a Python script to do this
            DNA pattern finding. That would be a lucky happy path, because we
            could rerun that script or update it later... Wait, that's handy...
            actually, more than handy... isn't that
            <code
              ><b><i>ideal</i></b></code
            >? Wouldn't it be better if we told it to write a script at the
            start? You see, the Code-Only agent doesn't need to be told to write
            a script. It
            <code
              ><b><i>has</i></b></code
            >
            to, because that's literally the only way for it to do anything of
            substance.
          </p>

          <p>
            The Code-Only agent produces something more precise than an answer
            in natural language. It produces a code <b><i>witness</i></b> of an
            answer. The answer is the output from running the code. The agent
            can interpret that output in natural language (or by writing code),
            but the "work" is codified in a very literal sense. The Code-Only
            agent doesn't respond with something. It produces a code witness
            that outputs something.
          </p>

          <p>
           <span style="color: #005abb"
									>Try ‚ùØ‚ùØ <a href="https://github.com/rvantonder/execute_code_py" style="text-decoration: underline wavy #005abb;">Code-Only plugin for Claude Code</a>
            </span>
          </p>

          <h2>Code witnesses are semantic guarantees</h2>

          <p>
            Let's follow the consequences. The code witness must abide by
            certain rules: The rules imposed by the language runtime semantics
            (e.g., of Python). That's not a "next token" process. That's not a
            "LLM figures out sequence of tool calls, no that's not what I
            wanted". It's piece of code. A piece of code! Our one-tool agent has
            a wonderful property: It went through latent space to produce
            something that has a defined semantics, repeatably runnable, and
            imminently comprehensible (for humans or agents alike to reason
            about). This is nondeterministic LLM token-generation projected into
            the space of Turing-complete code, an executable description of
            behavior as we best understand it.
          </p>

          <p>
            Is a Code-Only agent really enough, or too extreme? I'll be frank: I
            pursued this extreme after two things (1) inspiration from articles in <a href="#further-reading" style="text-decoration: underline; text-decoration-style: dotted;">Further Reading</a> below (2) being annoyed at agents for not comprehensively and
            exhaustively analyzing 1000s of files on my laptop. They would skip,
            take shortcuts, hallucinate. I knew how to solve part of that
            problem: create a
            <b
              ><i><code>programmatic</code></i></b
            >
            loop and try have fresh instances/prompts to do the work
            comprehensively. I can rely on the semantics of a loop written in
            Python. Take this idea further, and you realize that for anything
            long-running and computable (e.g., bash or some tool), you actually
            want the real McCoy: the full witness of code, a trace of why things
            work or don't work. The Code-Only agent
            <code
              ><i><b>enforces</b></i></code
            >
            that principle.
          </p>

          <p>
            Code-Only agents are not too extreme. I think they're the only way
            forward for computable things. If you're writing travel blog posts,
            you accept the LLMs answer (and you don't need to run tools for
            that). When something is computable though, Code-Only is the only
            path to a
            <b
              ><i><code>fully trustworthy</code></i></b
            >
            way to make progress where you need guarantees (subject to
            the semantics that your language of choice guarantees, of course). When I say
            guarantees, I mean that in the looser sense, and also in a
            <u
              ><a href="https://en.wikipedia.org/wiki/Formal_verification"
                >Formal</a
              ></u
            >
            sense. Which beckons: What happens when we use a language like
            <u><a href="https://lean-lang.org/">Lean</a></u> with some of the
            strongest guarantees? Did we not observe that
            <u
              ><a
                href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence"
                >programs are proofs</a
              ></u
            >?
          </p>

          <p>
            This lens says the Code-Only agent is a producer of proofs,
            witnesses of computational behavior in the world of
            proofs-as-programs. An LLM in a loop forced to produce proofs, run
            proofs, interpret proof results. That's all.
          </p>

          <h2>Going Code-Only</h2>

          <p>
            So you want to go Code-Only. What happens? The paradigm is simple,
            but the design choices are surprising.
          </p>

          <p>
            First, the harness. The LLM's output is code, and you execute that
            code. What should be communicated back? Exit code makes sense. What
            about output? What if the output is very large? Since you're running
            code, you can specify the result type that running the code should
            return.
          </p>

          <p>
            I've personally, e.g., had the tool return results directly if under
            a certain threshold (1K bytes). This would go into the session context.
						Alternatively, write the results to a JSON
            file on disk if it exceeds the threshold. This avoids context blowup and the result tells the
            agent about the output file path written to disk. How best to pass
            results, persist them, and optimize for size and context fill are
            open questions. You also want to define a way to deal with `stdout`
            and `stderr`: Do you expose these to the agent? Do you summarize
            before exposing?
          </p>

          <p>
            Next, enforcement. Let's say you're using Claude Code. It's not
            enough to persuade it to always create and run code. It turns out
            it's surprisingly twisty to force Claude Code into a single tool
            (maybe support for this will improve). The best plugin-based
            solution I found is a tool PreHook that catches banned tool uses.
            This wastes some iterations when Claude Code tries to use a tool
            that's not allowed, but it learns to stop attempting filesystem
            reads/writes. An initial prompt helps direct.
          </p>

          <p>
            Next, the language runtime. Python, TypeScript, Rust, Bash. Any
            language capable of being executed is fair game, but you'll need to
            think through whether it works for your domain. Dynamic languages
            like Python are interesting because you can run code natively in the
            agent's own runtime, rather than through subprocess calls. Likewise
            TypeScript/JS can be injected into TypeScript-based agents (see
            <a href="#further-reading" style="text-decoration: underline; text-decoration-style: dotted;">Further Reading</a>).
          </p>

          <p>
            Once you get into the Code-Only mindset, you'll see the potential
            for composition and reuse. Claude Skills define reusable processes
            in natural language. What's the equivalent for a Code-Only agent?
            I'm not sure a Skills equivalent exists yet, but I anticipate it
            will take shape soon: code as building blocks for specific domains
            where Code-Only agents compose programmatic patterns. How is that
            different from calling APIs? APIs form part of the reusable blocks,
            but their composition (loops, parallelism, asynchrony) is what a
            Code-Only agent generates.
          </p>

          <p>
            What about heterogeneous languages and runtimes for our `execute_tool`? I don't think we've thought that far yet.
          </p>

          <h2 id="further-reading">Further Reading</h2>

          <p>
            The agent landscape is quickly evolving. My thoughts on how the
            Code-Only paradigm fits into inspiring articles and trends, from
            most recent and going back:
          </p>

          <ul>
            <li>
              <u
                ><b><a href="https://prose.md">prose.md</a></b></u
              >
              (Jan 2026) ‚Äî Code-Only reduces prompts to executable code (with
              loops and statement sequences). Prose expands prompts into natural
              language with program-like constructs (also loops, sequences,
              parallelism). The interplay of natural language for agent
              orchestration and rigid semantics for agent execution could be
              extremely powerful.
            </li>
            <li>
              <u
                ><b
                  ><a
                    href="https://steve-yegge.medium.com/welcome-to-gas-town-4f25ee16dd04"
                    >Welcome to Gas Town</a
                  ></b
                ></u
              >
              (Jan 2026) ‚Äî Agent orchestration gone berserk. Tool running is the low-level
              operation at the bottom of the agent stack. Code-Only fits as the
              primitive: no matter how many agents you orchestrate, each one
              reduces to generating and executing code.
            </li>
            <li>
              <u
                ><b
                  ><a
                    href="https://www.anthropic.com/engineering/code-execution-with-mcp"
                    >Anthropic Code Execution with MCP article</a
                  ></b
                ></u
              >
              (Nov 2025) ‚Äî MCP-centric view of exposing MCP servers as code API
              and not tool calls. Code-Only is simpler and more general. It
              doesn't care about MCP, and casting the MCP interface as an API is
              a mechanical necessity that acknowledges the power of going
              Code-Only.
            </li>
            <li>
              <u
                ><b
                  ><a
                    href="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills"
                    >Anthropic Agent Skills article</a
                  ></b
                ></u
              >
              (Oct 2025) ‚Äî Skills embody reusable processes framed in natural
              language. They can generate and run code, but that's not their
              only purpose. Code-Only is narrower (but computationally
              all-powerful): the reusable unit is always executable. The analog
              to Skills manifests as pluggable executable pieces: functions,
              loops, composable routines over APIs.
            </li>
            <li>
              <u
                ><b
                  ><a href="https://blog.cloudflare.com/code-mode/"
                    >Cloudflare Code Mode article</a
                  ></b
                ></u
              >
              (Sep 2025) ‚Äî Possibly the earliest concrete single-code-tool
              implementation. Code Mode converts MCP tools into a TypeScript API
              and gives the agent one tool: execute TypeScript. Their insight is
              pragmatic: LLMs write better code than tool calls because of
              training data. In its most general sense, going Code-Only doesn't
              need to rely on MCP or APIs, and encapsulates all code execution
              concerns.
            </li>
            <li>
              <u
                ><b
                  ><a href="https://ghuntley.com/ralph/"
                    >Ralph Wiggum as a "software engineer"</a
                  ></b
                ></u
              >
              (Jul 2025) ‚Äî A programmatic loop over agents (agent
              orchestration). Huntley describes it as "deterministically bad in
              a nondeterministic world". Code-Only inverts this a bit:
              projection of a nondeterministic model into deterministic
              execution. Agent orchestration on top of an agent's Code-Only
              inner-loop could be a powerful combination.
            </li>
            <li>
              <u
                ><b
                  ><a href="https://lucumr.pocoo.org/2025/7/3/tools/"
                    >Tools: Code is All You Need</a
                  ></b
                ></u
              >
              (Jul 2025) ‚Äî Raises code as a first-order concern for agents.
              Ronacher's observation: asking an LLM to write a script to
              transform markdown makes it possible to reason about and trust the
              process. The script is reviewable, repeatable, composable.
              Code-Only takes this further where every action becomes a script
              you can reason about.
            </li>
            <li>
              <u
                ><b
                  ><a href="https://ampcode.com/how-to-build-an-agent"
                    >How to Build an Agent</a
                  ></b
                ></u
              >
              (Apr 2025) ‚Äî The cleanest way to achieve a Code-Only agent today
              may be to build it from scratch. Tweaking current agents like
              Claude Code to enforce a single tool means friction. Thorsten's
              article is a lucid account for building an agent loop with tool
              calls. If you want to enforce Code-Only, this makes it easy to do
              it yourself.
            </li>
          </ul>

          <h2>What's Next</h2>

          <p>
            Two directions feel inevitable. First, agent orchestration. Tools
            like <u><a href="https://prose.md">prose.md</a></u> let you compose
            agents in natural language with program-like constructs. What
            happens when those agents are Code-Only in their inner loop? You get
            natural language for coordination, rigid semantics for execution.
            The best of both.
          </p>

          <p>
            Second, hybrid tooling. Skills work well for processes that live in
            natural language. Code-Only works well for processes that need
            guarantees. We'll see agents that fluidly mix both: Skills for
            orchestration and intent, Code-Only for computation and precision.
            The line between "prompting an agent" and "programming an agent"
            will blur until it disappears.
          </p>

          <p>
            <span style="color: #005abb"
									>Try ‚ùØ‚ùØ <a href="https://github.com/rvantonder/execute_code_py" style="text-decoration: underline wavy #005abb;">Code-Only plugin for Claude Code</a>
            </span>
          </p>

          <hr style="margin: 40px 0" />
          <p id="fn1" style="font-size: 0.9em; color: #666">
            <sup>1</sup>There is something beautifully
            <a
              style="text-decoration: underline"
              href="https://en.wikipedia.org/wiki/Quine_(computing)"
              >quine-like</a
            >
            about this agent. I've always
            <a
              style="text-decoration: underline"
              href="https://github.com/rvantonder/pentaquine"
              >loved quines</a
            >.
          </p>
        </article>
      </main>
    </div>
  </body>
</html>

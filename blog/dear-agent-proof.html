<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dear Agent: Prove it. ‚Ä¢ Rijnard van Tonder</title>
    <meta
      name="description"
      content="Count the number of r's in strawberry. Actually no, prove it instead."
    />

    <link rel="stylesheet" href="../assets/normalize.css" />
    <link rel="stylesheet" href="../assets/main.css" />
    <link
      href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Vollkorn"
      rel="stylesheet"
      type="text/css"
    />
    <link
      rel="canonical"
      href="https://rijnard.com/blog/dear-agent-proof"
    />

    <style>
      /* Override default center alignment for author name - make it right aligned on all screen sizes */
      .author-container h1,
      .author-container p {
        text-align: right;
      }

      /* Make blog nav left aligned on mobile, centered above hr */
      @media (max-width: 767px) {
        .blog-nav {
          text-align: left;
        }
        .content code {
          font-weight: 600;
        }
      }

      /* Remove bullet indentation in article */
      .content ul {
        padding: 0 !important;
        margin: 10px !important;
        list-style-position: inside;
      }

      .content ul li {
        margin-bottom: 1em;
        text-align: justify;
      }

      /* Blog-specific wider layout for desktop */
      @media (min-width: 768px) {
        .wrapper {
          width: 900px;
        }
        header {
          width: 20%;
        }
        main {
          width: 58%;
          margin-left: 35%;
        }
      }

      /* Blue accent color for this post */
      .content h2 {
        color: #005abb;
      }

      .content hr {
        border-color: #005abb;
      }

      /* Hand-drawn brushstroke underline effect */
      .stroke-underline {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 30' preserveAspectRatio='none'%3E%3Cpath d='M0 18 C3 16 8 14 15 13 C30 11 50 10 100 12 C150 14 175 13 190 15 C196 16 200 17 200 18 L200 22 C198 21 192 19 185 18 C170 16 145 17 100 16 C55 15 30 17 15 19 C8 20 3 22 0 24 Z' fill='%23005abb'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-size: 100% 0.4em;
        background-position: 0 90%;
      }

      /* Inline code styling - subtle and smaller */
      .content code {
        background-color: #c4e9ff;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 0.9em;
        font-family: 'Courier New', monospace;
      }

      /* Code blocks - horizontal scroll if overflow */
      .content pre {
        overflow-x: auto;
        overflow-y: hidden;
        border-top: 1px solid #005abb;
        border-left: 1px solid #005abb;
        border-bottom: 3px double #005abb;
        border-right: 3px double #005abb;
        padding: 15px 20px;
        margin: 1.5em 0;
        background-color: #f8f9fa;
      }

      .content pre code {
        background-color: transparent;
        padding: 0;
      }

      /* Emphasis class for non-code emphasis (like in code-only-agent.html) */
      .content .emph {
        font-family: 'Courier New', monospace;
        /* No background, no padding - just monospace emphasis */
      }

      /* Prompt block styling */
      .prompt-block {
        border-top: 1px solid #005abb;
        border-left: 1px solid #005abb;
        border-bottom: 3px double #005abb;
        border-right: 3px double #005abb;
        padding: 15px 20px;
        margin: 1.5em 0;
        background-color: #f8f9fa;
      }

      /* Lean syntax highlighting */
      .lean-keyword { color: #9d4edd; font-weight: bold; }
      .lean-comment { color: #6c757d; font-style: italic; }
      .lean-type { color: #0077b6; font-weight: 500; }
      .lean-function { color: #005abb; font-weight: 500; }
      .lean-operator { color: #495057; }
      .lean-literal { color: #2a9d8f; }
      .lean-return, .content code.lean-return { background-color: #fff755; padding: 2px 4px; border-radius: 3px; }
    </style>

    <meta name="author" content="Rijnard van Tonder" />
    <meta property="og:title" content="Dear Agent: Prove it." />
    <meta
      property="og:description"
      content="Count the number of r's in strawberry. Actually no, prove it instead. Why tests won't save us and how formal verification becomes essential when agents write our code."
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://rijnard.com/blog/dear-agent-proof.html"
    />
    <meta
      property="og:image"
      content="https://rijnard.com/assets/og-proof-agent.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@rvtond" />
    <meta
      name="twitter:image"
      content="https://rijnard.com/assets/og-proof-agent.png"
    />
    <script
      async
      defer
      data-domain="rijnard.com"
      src="https://plausible.io/js/plausible.js"
    ></script>
  </head>

  <body>
    <div id="base" class="wrapper">
      <header>
        <div class="author-container">
          <p style="font-size: 1.5rem; margin: 0">
            <a href="../index.html">Rijnard<br />van Tonder</a>
          </p>
          <p style="font-size: 0.9rem; margin: 0; padding: 0;">
            <a href="https://x.com/rvtond" style="text-decoration: underline;">ùïè @rvtond</a>
          </p>
        </div>
        <hr />
        <nav class="blog-nav">
          <a style="text-decoration: underline" href="../index.html">Home</a>
          <br />
          <a style="text-decoration: underline" href="index.html"
            >‚Üê Back to all posts</a
          >
        </nav>
      </header>

      <main>
        <article class="content">
          <h1 style="color: #005abb">Dear Agent: <span class="stroke-underline">Prove it.</span></h1>
          <p style="font-size: 1.2em; font-style: italic; margin: 0;">
            Count the number of r's in strawberry. Actually no, prove it instead.
          </p>

          <p style="text-align: center; margin: 0; padding-top: 1.2em; padding-bottom: 0.8em;">
            <img src="../assets/proof-agent.png" alt="Prompt to Proof" style="max-width: 70%; height: auto; margin: 0;" />
          </p>

          <p style="margin-top: 0em;">
            At some point it became possible to write the following prompt, and any frontier LLM will give you a correct answer.
          </p>

          <div class="prompt-block">
            &gt; <b><i>Write a Lean program that counts the number of times a character occurs in a string. Prove it's correct.</i></b>
          </div>

          <p>
            You'll get a program like this, or some variation of it. We'll walk through it in just a minute.
          </p>

          <pre><code><span class="lean-comment">/-- Count occurrences of a character in a list. -/</span>
<span class="lean-keyword">def</span> <span class="lean-function">countCharList</span> (c : <span class="lean-type">Char</span>) : <span class="lean-type">List Char</span> <span class="lean-operator">‚Üí</span> <span class="lean-type">Nat</span>
<span class="lean-operator">|</span> []      <span class="lean-operator">=&gt;</span> <span class="lean-literal">0</span>
<span class="lean-operator">|</span> x :: xs <span class="lean-operator">=&gt;</span> (<span class="lean-keyword">if</span> x = c <span class="lean-keyword">then</span> <span class="lean-literal">1</span> <span class="lean-keyword">else</span> <span class="lean-literal">0</span>) + <span class="lean-function">countCharList</span> c xs

<span class="lean-comment">/-- Count occurrences of a character in a string. -/</span>
<span class="lean-keyword">def</span> <span class="lean-function">countChar</span> (c : <span class="lean-type">Char</span>) (s : <span class="lean-type">String</span>) : <span class="lean-type">Nat</span> <span class="lean-operator">:=</span>
  <span class="lean-function">countCharList</span> c s.toList

<span class="lean-comment">/-- Correctness proof: our function matches `List.count`. -/</span>
<span class="lean-keyword">theorem</span> <span class="lean-function">countChar_correct</span> (c : <span class="lean-type">Char</span>) (s : <span class="lean-type">String</span>) :
  <span class="lean-function">countChar</span> c s = s.toList.count c <span class="lean-operator">:=</span> <span class="lean-keyword">by</span>
  <span class="lean-keyword">unfold</span> <span class="lean-function">countChar</span>
  <span class="lean-keyword">induction</span> s.toList <span class="lean-keyword">with</span>
  <span class="lean-operator">|</span> nil <span class="lean-operator">=&gt;</span>
      <span class="lean-keyword">simp</span> [<span class="lean-function">countCharList</span>]
  <span class="lean-operator">|</span> cons x xs ih <span class="lean-operator">=&gt;</span>
      <span class="lean-keyword">simp</span> [<span class="lean-function">countCharList</span>, ih]
      <span class="lean-keyword">by_cases</span> h : x = c <span class="lean-operator">&lt;;&gt;</span> <span class="lean-keyword">simp</span> [h]</code></pre>

          <p>
            At first we laughed at LLMs which couldn't even count letters in a word. Now we can reliably ask it to write a Python program to count the number of characters in a string and it'll nail it.
          </p>

          <p>
            We still have to check that the Python code looks good, maybe we'll write some tests.
          </p>

          <p>
            Above, however, we have <span class="emph"><b><i>The Ultimate</i></b></span> program for this task. It's not just a Python program we need to check for correctness. It's a program that is <b><i>proven</i></b> correct for all inputs it accepts.
          </p>

          <p>
            Once and for all. No tests needed. Done.
          </p>

          <p>
            We now know we can write (or generate) a correct program to count the number of characters in a string, and we don't need to do that ever again. How incredible is that?
          </p>

          <h2>Formal Verification: Not a Primer</h2>

          <p>
            Our character-counting program is written in <a href="https://lean-lang.org/" style="text-decoration: underline;">Lean</a>, a language for doing Formal Verification.
          </p>

          <p>
            We'll walk through the main bits so that you, the working programmer, have a chance at the "ah-ha" moment. Know that the field is deep, and those who venture deep into Formal Verification mostly forget to come back and explain it to the rest of us.
          </p>

          <p>
            In Lean you can write proofs for your programs with respect to specifications. Specifications describe how a program must behave, and good specifications obviate the need for tests, because they cover all possible inputs and guarantee behavior over all outputs.
          </p>

          <p>
            Writing good specifications used to be very tedious and hard. Now they're just hard, thanks to LLMs.
          </p>

          <h2>Make Agents Prove</h2>

          <p>
            On to the example.
            Here's the character-counting function in Lean:
          </p>

          <pre><code><span class="lean-comment">/-- Count occurrences of character `c` in string `s`. -/</span>
<span class="lean-keyword">def</span> <span class="lean-function">countChar</span> (c : <span class="lean-type">Char</span>) (s : <span class="lean-type">String</span>) : <span class="lean-type">Nat</span> <span class="lean-operator">:=</span>
  <span class="lean-keyword">match</span> s.toList <span class="lean-keyword">with</span>
  <span class="lean-operator">|</span> []      <span class="lean-operator">=&gt;</span> <span class="lean-literal">0</span>
  <span class="lean-operator">|</span> x :: xs <span class="lean-operator">=&gt;</span> (<span class="lean-keyword">if</span> x = c <span class="lean-keyword">then</span> <span class="lean-literal">1</span> <span class="lean-keyword">else</span> <span class="lean-literal">0</span>) + <span class="lean-function">countChar</span> c xs.asString</code></pre>

          <p>
            Don't worry about the functional style here. It's not a big deal, we wrote a function to count characters, you could do the same in Python.
          </p>

         <p>
            So we have a character <code>c</code>, a string <code>s</code>, and our function <code>countChar</code>. This function is the thing we are going to <i>prove</i> is correct, that it <i>actually</i> counts the number of times <code>c</code> is in <code>s</code>.
          </p>

          <p>
					We'll put our specification and proof in the <code style="color: #9d4edd; font-weight: bold; background-color: transparent;">theorem</code> part of Lean, and this is where things get interesting. You can think of <code style="color: #9d4edd; font-weight: bold; background-color: transparent;">theorem</code> as a programmatic construct that lives next to your code, and says things about your code. We'll call our theorem <code>countChar_is_correct</code>.
          </p>

          <p>
					There are multiple ways to express the behavior that <code>countChar</code> counts characters. So bear with me for simplicity: we'll use Lean's built-in <code>s.toList.count c</code> that's been proven correct internally, and we're going to trust that as our reference implementation. The proof setup is then: show that <span class="emph"><i><b>our</b></i></span> <code>countChar</code> is consistent with this reference. Here is the proof setup expressed in Lean code, where <code style="color: #9d4edd; font-weight: bold; background-color: transparent;">theorem</code> gets used:
          </p>

          <pre><code><span class="lean-keyword">theorem</span> <span class="lean-function">countChar_is_correct</span> (c : <span class="lean-type">Char</span>) (s : <span class="lean-type">String</span>) :
  <span class="lean-return"><span class="lean-function">countChar</span> c s = s.toList.count c</span> <span class="lean-operator">:=</span> <span class="lean-keyword">by</span> ...</code></pre>

          <p>
            If you've used TypeScript, you'll know you can assign types like <code>number</code> and <code>string</code> to variables. Our theorem has a type too. Here it is, highlighted:
          </p>
          <p>
           <code class="lean-return">countChar c s = s.toList.count c</code>
          </p>

          <p>
					Something Super Not Normal is happening here. This whole thing is a type. That <code>=</code> demands you construct a proof that both sides are equivalent. And the type references <span class="emph"><b><i>concrete parameters</i></b></span> <code>c</code> and <code>s</code> freely. It's just allowed to do that. The type can use equivalences, parameters, functions, etc. to express provable claims about your program.           </p>

          <p>
            So that's the ah-ha: Lean gives you this special language where you can express these specifications; a kind of sidecar to your implementation. Those specifications are mathematical propositions, and represented as types. If this idea is new to you, hopefully you're now realizing <b><i>this is not normal.</i></b> <code>countChar c s = s.toList.count c</code> has mathematical meaning that Lean understands, and rules it can follow to prove it true.
You can literally go and write down: Okay, so I have this function I wrote that takes <code>s</code> and <code>c</code>, and if I give that <code>s</code> and <code>c</code> to another function that exists, I want to prove that they do the same thing.
						What!<sup>2</sup>

          </p>

          <p>
						The proof itself is the part after <code>:= by ...</code>

            I'm going to gloss a bit over this proof implementation, because it's less instructive (do ask your favorite agent to explain it to you). In essence, Lean provides constructs, like proof by induction, to reduce complex proofs into simpler steps that can be mechanically verified. The point is...
          </p>

          <h2>It is correct if the agent succeeds</h2>

          <p>
            Once we've written a specification (required program behavior) it doesn't matter what an LLM generates. It can only generate a program that is proven correct, or it cannot.
          </p>

					<p>
					We can ask an agent to try prove something without caring about the proof language or mechanisms that Lean uses.
For example, you can express <a href="https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem" style="text-decoration: underline;">Fermat's Last Theorem</a> in Lean, without knowing whether a proof exists (<code>sorry</code> is a placeholder until we can prove the theorem).
					</p>

          <pre><code><span class="lean-keyword">theorem</span> <span class="lean-function">fermats_last_theorem</span> :
  <span class="lean-keyword">forall</span> n : <span class="lean-type">Nat</span>, n >= <span class="lean-literal">3</span> -> <span class="lean-keyword">forall</span> a b c : <span class="lean-type">Nat</span>, a > <span class="lean-literal">0</span> -> b > <span class="lean-literal">0</span> -> c > <span class="lean-literal">0</span> -> a^n + b^n != c^n <span class="lean-operator">:=</span> <span class="lean-keyword">by</span>
  <span class="lean-keyword">sorry</span></code></pre>

          <p>
					Mathematical intuition will go a long way to steering specs, just like good software engineering intuition would steer good software specifications. What's beautiful is you can write things down and send it, steer it. 
            That's what the example shows off: we are challenged to write a function based on a known reference implementation, and Lean tells us if our implementation is <i>correct</i> or not. That proof is independently verifiable.
          </p>

          <p>
Do you realize how crazy it is that LLMs can explore proof-writing sufficiently well for non-trivial properties now? Frontier models today one-shot the example counting program.
          </p>

          <p>
            Of course specifications can be wrong. Or underspecified and weak. For example, we could write a specification that the count of characters is always zero or more. That's provable, but not really useful. Specification quality is the hard part.<sup>3</sup> Writing specifications that are both correct and complete requires deep understanding of the problem domain, and where expertise matters.
          </p>

          <p>
            You're already thinking it, so I don't really have to say it. What if agents became expert and wrote the specifications? Indeed. That's still difficult, but surely they'll get better? Indeed. And we can have them implement the functions as well, and prove it. Indeed, why not? And then...
          </p>

          <h2>The case for proofs</h2>

          <p>
            So you can see what I see: A path that goes from taking a nondeterministic LLM, and not just producing operational code, but producing computationally correct operational code. There is effectively no stronger guarantee we can impose on (<a href="https://en.wikipedia.org/wiki/Decidability_(logic)" style="text-decoration: underline;">decidable</a>) software than to demand a proof alongside its implementation.
          </p>

          <p>
            Formal verification is a hardcore approach. It is difficult and it is the holy grail of software engineering. LLMs have made it much more accessible to humans and, more importantly, non-humans.<sup>1,3</sup>
          </p>

          <p>
            If the specification is good, we don't need tests. It makes <span class="emph"><i><b>no sense</b></i></span> to test whether there are three r's in strawberry and not two, when we have <i>proved</i> that the answer <i>is correct</i> for every possible character / string inputs.
          </p>

          <h2>But also tests won't save you</h2>

          <p>
            There's a much more alarming trend that makes the case for agents that prove.
          </p>

          <p>
            <span class="emph"><i><b>Tests are too optimistic for where we're headed.</b></i></span>
          </p>

          <p>
            Let's play it out. Agents write your code now, you just prompt. The junior devs too. You fend against the onslaught of code in the only reasonable way: prompt the agent to review the code as well.
            Because the anxiety of reviewing 3,000 LOC pull requests is too much. Tomorrow more is on the way. What's the anchor for these changes, how do we trust them? Tests! Yes, those will help.
          </p>

          <p>
            Well, we don't have time to write those, so let the agent write tests as well. Hm.
          </p>

          <p>
            But for humans to even judge whether a generated test suite is "good" is too much of a cognitive ask now. We're generating perfectly operational code too efficiently. At best we skim but mostly we just trust SuperLLM@20280208 did a good job on those tests.
          </p>

          <p>
            It's wildly uncomfortable to think tests are pointless, but that's where we're headed. Tests will be pointless. There I said it.
          </p>

          <h2>Proof not optional</h2>

          <p>
            I think we end up here in 2 to 3 years:
          </p>

          <p>
            (a) Agents introspect their own behavior and adapt "soft" software on-the-fly. Code is liquid. We have enough confidence that the LLM writes good code that doesn't need checking (e.g., static site generator). Tests are cruft.
          </p>
          <p>
            (b) Crucial, core software is written by agents and requires a proof witness and verifiable spec. The kind that controls private keys, writes auth code, encryption.
          </p>

          <p>
            We know now that agents generate operational code at volumes humans never could. And when used for red teaming, they will relentlessly probe every gap, every edge case, every vulnerability. They only need to find one chink in the armor, and it's over. When code generation is relentless and attacks are relentless, formal verification is the only way to definitively say "this code is an impenetrable bastion".
          </p>

          <p>
            The end game is: Prove or do not, there is no try.
          </p>

          <h2>Further Reading</h2>
          <ul style="list-style: none">
            <li>
              [1] <u><b><a href="the-code-only-agent">The Code-Only Agent</a></b></u> ‚Äî What if we made agents <i>always</i> generate code, so that they always have behavior to prove?
            </li>

            <li>
              [2] <u><b><a href="https://en.wikipedia.org/wiki/Lambda_cube">Lambda Cube</a></b></u> ‚Äî If you got the sense that our proof specification feels like programming in 3D, you wouldn't be far off. Lean sits in the corner with the most expressive type system, enabling dependent types and proof construction.
            </li>

            <li>
              [3] <u><b><a href="https://www.galois.com/articles/specifications-dont-exist">Specifications Don't Exist</a></b></u> and <u><b><a href="https://www.galois.com/articles/claude-can-sometimes-prove-it">Claude Can Sometimes Prove It</a></b></u>. The bottleneck in Formal Verification is obtaining good specifications. Claude Code shows surprising capability at interactive theorem proving in Lean, but still requires expert oversight.
            </li>

            <li>
              [4] <u><b><a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard Correspondence</a></b></u> ‚Äî The deep connection between programs and proofs, propositions and types. Understanding this helps to understand why formal verification in languages like Lean is possible at all.
            </li>

            <li>
              [5] <b>Other proof languages.</b> Besides Lean there's <u><b><a href="https://fstar-lang.org/">F*</a></b></u>, <u><b><a href="https://rocq-prover.org/">Rocq</a></b></u>, <u><b><a href="https://dafny.org/">Dafny</a></b></u>, <u><b><a href="https://isabelle.in.tum.de/">Isabelle/HOL</a></b></u>, <u><b><a href="https://agda.readthedocs.io/">Agda</a></b></u>. Each makes different tradeoffs between automation and expressiveness. Exploring these may lead you to rabbit hole territory, because they differ on <i>what counts as a proof</i>. Lean has the momentum right now: it's where the AI tooling, the math community, and the developer ergonomics are converging.
            </li>
          </ul>

          <h2>What's Next</h2>

          <p>
            I won't pretend we'll just end up in a world where all code has good specifications and is proved correct. It will take hard work in between. Performance can suffer: Lean programs can be slow, and extraction to efficient languages adds complexity. Still, there are rich opportunities to overcome these.
          </p>

          <p>
            AI √ó Formal Verification is one of the most demanding things you could choose to work on right now. Today, the most demanding things are the ones with staying power. After thousands of hours of prompting and engineering with agents, I realized this deserves more exposure now, if you want to keep being relevant in software. It will absolutely need to be cracked in the end game. The payoff is huge.
          </p>

          <hr style="margin: 40px 0; background-image: linear-gradient(to right, transparent, #005abb, transparent);" />

          <p style="margin-top: 2em;">
            Follow me on <a href="https://x.com/rvtond" style="text-decoration: underline;">&#x1D54F;</a> for more posts on building Agents and Formal Verification.
          </p>

          <form
            action="https://buttondown.com/api/emails/embed-subscribe/rijnard"
            method="post"
            class="embeddable-buttondown-form"
            referrerpolicy="unsafe-url"
            style="margin: 1.5em 0; padding: 18px 22px; border: 1px solid #d0d7de; border-radius: 6px; background-color: #f6f8fa;"
          >
            <p style="margin: 0 0 10px; font-size: 0.9em; color: #555;">Occasional posts on agents, formal verification, and building software that lasts.</p>
            <div style="display: flex; gap: 8px;">
              <input type="email" name="email" id="bd-email" placeholder="you@example.com" required style="flex: 1; padding: 8px 10px; border: 1px solid #d0d7de; border-radius: 4px; font-family: inherit; font-size: 0.9em; color: #333;" />
              <input type="submit" value="Subscribe" style="padding: 8px 18px; background-color: #4a90c4; color: #fff; border: none; border-radius: 4px; font-family: inherit; font-size: 0.9em; cursor: pointer;" />
            </div>

          </form>

          <div style="display: flex; align-items: center; gap: 12px; margin-top: 1em; padding-left: 5px;">
            <span style="font-size: 0.8em; color: #888;">Share</span>
            <a href="https://twitter.com/intent/tweet?text=Dear%20Agent%3A%20Prove%20it.&amp;url=https%3A%2F%2Frijnard.com%2Fblog%2Fdear-agent-proof.html" target="_blank" rel="noopener noreferrer" aria-label="Share on Twitter" style="color: #888;"><svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg></a>
            <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Frijnard.com%2Fblog%2Fdear-agent-proof.html" target="_blank" rel="noopener noreferrer" aria-label="Share on LinkedIn" style="color: #888;"><svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg></a>
            <a href="https://news.ycombinator.com/submitlink?u=https%3A%2F%2Frijnard.com%2Fblog%2Fdear-agent-proof.html&amp;t=Dear%20Agent%3A%20Prove%20it." target="_blank" rel="noopener noreferrer" aria-label="Share on Hacker News" style="color: #888;"><svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0v24h24V0H0zm12.3 13.27c-.15.27-.29.53-.44.78-.15.25-.29.5-.43.73V20h-1.9v-5.02c-.15-.29-.31-.58-.47-.87-.16-.28-.33-.57-.49-.85L6.1 8.8h2.13l2.22 4.28 2.27-4.28h2.1l-2.52 4.47z"></path></svg></a>
          </div>

          <small class="small-sty" style="padding-left: 5px;">
            <span>Timestamped</span> <i class="fa fa-calendar"></i> 8 Feb 2026
          </small>
          <br>
        </article>
      </main>
    </div>
  </body>
</html>
